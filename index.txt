<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firearm Report Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 800px;
        }
        /* Custom styling for the report header to ensure the logo looks clean */
        #report-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 1rem;
        }
        /* Styling to prevent line breaking on valuation numbers */
        .no-break {
            white-space: nowrap;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center">
    <div class="container bg-white rounded-3xl shadow-xl p-8 space-y-8">
        <header class="text-center">
            <h2 id="cabelas-logo" class="mx-auto text-yellow-600 text-3xl font-bold mb-4">Dealer Logo</h2>
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">Firearm Report Generator</h1>
            <p class="text-gray-500">Upload, paste, or drag and drop photos to identify your firearm and generate a report.</p>
            <p id="user-id" class="text-xs text-gray-400 mt-2"></p>
        </header>

        <div id="drop-zone" class="w-full rounded-2xl border-4 border-dashed border-gray-300 p-8 text-center transition-colors hover:border-gray-400">
            <input type="file" id="file-input" class="hidden" accept="image/*" multiple>
            <div class="text-lg font-medium text-gray-700">Drag & drop, paste (Ctrl+V), or click to upload images</div>
            <p class="text-sm text-gray-400 mt-2">Maximum of 6 images, up to 4MB each.</p>
            <button id="upload-button" class="mt-6 px-6 py-3 bg-gray-900 text-white font-semibold rounded-xl hover:bg-gray-700 transition-colors">
                Choose Images
            </button>
        </div>

        <div class="w-full">
            <div class="flex flex-col gap-3">
                <label for="url-input" class="text-sm font-medium text-gray-700">To add images from the internet, find an image, right-click it, and select "Copy Image Address". Then paste the URL below.</label>
                <div class="flex items-center gap-3">
                    <input type="text" id="url-input" placeholder="Paste image URL here..." class="flex-grow rounded-xl p-3 border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <button id="url-button" class="px-6 py-3 bg-gray-900 text-white font-semibold rounded-xl hover:bg-gray-700 transition-colors">
                        Add from URL
                    </button>
                </div>
            </div>
        </div>
        
        <div class="w-full">
            <div class="flex flex-col gap-3">
                <label for="notes-input" class="text-sm font-medium text-gray-700">Optional notes for identification (e.g., serial numbers, specific markings, history):</label>
                <textarea id="notes-input" rows="3" class="rounded-xl p-3 border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
            </div>
        </div>

        <div id="image-previews" class="flex flex-wrap gap-4 justify-center items-center p-4 rounded-xl bg-gray-50 shadow-inner" style="display: none;"></div>

        <div class="flex flex-col items-center justify-center space-y-4">
            <button id="generate-button" class="w-full px-8 py-4 bg-indigo-600 text-white font-bold text-lg rounded-2xl shadow-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                Generate Report
            </button>
            
            <button id="download-button" class="w-full px-8 py-4 bg-gray-500 text-white font-bold text-lg rounded-2xl shadow-lg hover:bg-gray-600 transition-colors hidden">
                Download Report
            </button>
            <div id="status-message" class="text-sm text-center text-gray-600"></div>
        </div>

        <div id="report-container" class="w-full bg-white rounded-2xl shadow-lg p-6 space-y-6" style="display: none;">
            <div id="report-header">
                <h3 class="text-xl font-bold text-yellow-600 mx-auto mb-2">Dealer Logo</h3>
                <h2 class="text-2xl font-bold text-gray-900">Firearm Identification Report</h2>
            </div>
            <div id="report-content" class="space-y-4"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ?
        __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // ***************************************************************
        // CRITICAL SECURITY: The API key is set to an empty string.
        // For local testing, you must manually paste your new key here.
        // For production, the key should be injected securely by your hosting service.
        const API_KEY = "";
        // ***************************************************************
        
        // --- NEW: Price Adjustment Setting ---
        const PRICE_ADJUSTMENT_PERCENTAGE = 0.05;
        // 5% reduction on wholesale price

        let reportData = null;
        // Variable to hold the report data

        // --- Firebase Initialization ---
        let app, db, auth, userId;
        let isAuthReady = false;

        async function initFirebase() {
            try {
                // Only initialize if config is not empty (i.e., running in the Canvas environment)
                if (Object.keys(firebaseConfig).length === 0) {
                    console.warn("Firebase configuration is missing. Running in local mode without persistence.");
                    isAuthReady = true; // Still allow app to run if no auth needed
                    userId = crypto.randomUUID();
                    document.getElementById('user-id').textContent = `User ID: (Local) ${userId.substring(0, 8)}...`;
                    return;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser.uid;
                document.getElementById('user-id').textContent = `User ID: ${userId}`;
                isAuthReady = true;
                console.log("Firebase initialized successfully.");
            } catch (error) {
                console.error("Firebase initialization error:", error);
                document.getElementById('status-message').textContent = "Failed to connect to the database. Some features may not work.";
            }
        }
        initFirebase();

        // --- DOM Elements ---
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const uploadButton = document.getElementById('upload-button');
        const urlInput = document.getElementById('url-input');
        const urlButton = document.getElementById('url-button');
        const notesInput = document.getElementById('notes-input');
        const generateButton = document.getElementById('generate-button');
        // const claudeButton = document.getElementById('claude-button'); // REMOVED
        const downloadButton = document.getElementById('download-button');
        const imagePreviewsContainer = document.getElementById('image-previews');
        const statusMessage = document.getElementById('status-message');
        const reportContainer = document.getElementById('report-container');
        const reportContent = document.getElementById('report-content');

        let selectedFiles = [];
        const MAX_FILES = 6;
        const MAX_FILE_SIZE_MB = 4;
        const MAX_IMAGE_SIDE_PX = 800;
        // New: Max dimension for image processing
        
        // List of unsupported MIME types for the current Gemini Vision model
        const UNSUPPORTED_MIME_TYPES = ['image/avif', 'image/svg+xml'];

        // --- Utility Functions ---

        /** Rounds a number up to the nearest multiple of 5. */
        function roundUpToNearestFive(num) {
            if (isNaN(num) || num <= 0) return 0;
            return Math.ceil(num / 5) * 5;
        }

        function showMessage(message, type = 'info') {
            statusMessage.className = `text-sm text-center mt-4 ${type === 'error' ?
            'text-red-600' : 'text-gray-600'}`;
            statusMessage.textContent = message;
        }

        function toggleGenerateButton() {
            generateButton.disabled = selectedFiles.length === 0;
            // claudeButton.disabled = selectedFiles.length === 0; // REMOVED
            if (selectedFiles.length === 0) {
                downloadButton.classList.add('hidden');
            }
        }

        function showPreviews() {
            imagePreviewsContainer.innerHTML = '';
            if (selectedFiles.length > 0) {
                imagePreviewsContainer.style.display = 'flex';
                selectedFiles.forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imgWrapper = document.createElement('div');
                        imgWrapper.className = 'relative group w-32 h-32 rounded-lg overflow-hidden shadow-md';
                        imgWrapper.innerHTML = `
                            <img src="${e.target.result}" alt="Preview ${index + 1}" class="w-full h-full object-cover">
                            <button class="absolute top-1 right-1 bg-black/50 text-white rounded-full p-1 leading-none text-sm opacity-0 group-hover:opacity-100 transition-opacity" data-index="${index}">
                                &times;
                            </button>
                        `;
                        imagePreviewsContainer.appendChild(imgWrapper);
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                imagePreviewsContainer.style.display = 'none';
            }
        }

        function processFiles(files) {
            let newFiles = Array.from(files).filter(file => {
                const mimeType = file.type.toLowerCase();
                
                if (!mimeType.startsWith('image/')) {
                    showMessage(`File "${file.name}" is not an image.`, 'error');
                    return false;
                }
                
                // Explicitly check for unsupported MIME types
                if (UNSUPPORTED_MIME_TYPES.includes(mimeType)) {
                     showMessage(`File "${file.name}" uses an unsupported image format (${file.type}). Please use JPG or PNG.`, 'error');
                     return false;
                }

                if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                    showMessage(`File "${file.name}" exceeds the ${MAX_FILE_SIZE_MB}MB size limit.`, 'error');
                    return false;
                }
                return true;
            });
            if (selectedFiles.length + newFiles.length > MAX_FILES) {
                const limit = MAX_FILES - selectedFiles.length;
                newFiles = newFiles.slice(0, limit);
                showMessage(`Maximum image limit reached. Added ${limit} new files. Total: ${MAX_FILES}/${MAX_FILES}`, 'error');
            }

            selectedFiles = [...selectedFiles, ...newFiles].slice(0, MAX_FILES);
            showPreviews();
            toggleGenerateButton();
            if (newFiles.length > 0) {
                showMessage(`Added ${newFiles.length} files. Total: ${selectedFiles.length}/${MAX_FILES}`);
            }
        }

        // --- NEW: Image Resizing Function for Stability ---
        /** Resizes an image Blob down to a maximum dimension (e.g., 800px) for stable API processing.
        */
        function resizeImage(file) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Determine if resizing is necessary
                    if (width > MAX_IMAGE_SIDE_PX || height > MAX_IMAGE_SIDE_PX) {
                        const ratio = Math.max(width / MAX_IMAGE_SIDE_PX, height / MAX_IMAGE_SIDE_PX);
                        width /= ratio;
                        height /= ratio;
                    }

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // --- CRITICAL FIX: Changing to PNG encoding for stability test ---
                    canvas.toBlob(blob => {
                        // Use PNG mime type
                        const resizedFile = new File([blob], file.name, { type: 'image/png' });
                        resolve(resizedFile);
                    }, 'image/png'); 
                };
                img.src = URL.createObjectURL(file);
            });
        }
        // --- END: Image Resizing Function ---


        // --- Event Listeners ---

        uploadButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            processFiles(e.target.files);
            e.target.value = ''; // Clear input for next selection
        });
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-gray-500', 'bg-gray-50');
        });
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-gray-500', 'bg-gray-50');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-gray-500', 'bg-gray-50');
            processFiles(e.dataTransfer.files);
        });
        window.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            let files = [];
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                    const file = items[i].getAsFile();
                    files.push(file);
                }
            }
            if (files.length > 0) {
                processFiles(files);
            }
        });
        urlButton.addEventListener('click', async () => {
            const url = urlInput.value.trim();
            if (!url) {
                showMessage('Please enter a valid image URL.', 'error');
                return;
            }
            if (selectedFiles.length >= MAX_FILES) {
                showMessage(`You have reached the maximum of ${MAX_FILES} images.`, 'error');
                return;
            }

            // Simple validation for common image extensions
            if (!url.match(/\.(jpeg|jpg|gif|png|webp|svg|avif)$/i)) { // Added avif here to catch it before fetching
                showMessage('The URL does not look like a direct image link (e.g., must end in .jpg).', 'error');
                 return;
            }
            
            showMessage('Fetching image from URL... This might fail due to Cross-Origin (CORS) policies.', 'info');
            urlButton.disabled = true;

            try {
                // Using a proxy might be necessary for CORS, but we rely on the browser's native fetch.
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const contentType = response.headers.get('Content-Type')?.toLowerCase();
                if (!contentType || !contentType.startsWith('image/')) {
                    throw new Error(`URL did not return an image. Content-Type: ${contentType}`);
                }
                
                // Explicit check for unsupported MIME types retrieved from header
                if (UNSUPPORTED_MIME_TYPES.includes(contentType)) {
                     showMessage(`Image from URL uses an unsupported format (${contentType}). Please use JPG or PNG.`, 'error');
                    return;
                }

                const blob = await response.blob();
                // Create a File object from the Blob
                const filename = url.substring(url.lastIndexOf('/') + 1) ||
                'image';
                const file = new File([blob], filename, { type: blob.type });
                // Manually check size, as processFiles relies on file object properties
                if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                    showMessage(`Image from URL exceeds the ${MAX_FILE_SIZE_MB}MB size limit.`, 'error');
                } else {
                    processFiles([file]);
                    urlInput.value = '';
                    showMessage('Image added successfully from URL.');
                }
            } catch (error) {
                console.error(error);
                showMessage(`Failed to load image from URL: ${error.message}. This may be due to a Cross-Origin Resource Sharing (CORS) policy.`, 'error');
            } finally {
                urlButton.disabled = false;
            }
        });

        imagePreviewsContainer.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const index = e.target.getAttribute('data-index');
                selectedFiles.splice(index, 1);
                showPreviews();
                toggleGenerateButton();
                showMessage(`Removed image ${parseInt(index) + 1}.`);
            }
        });

        // --- LLM and Report Generation (Gemini) ---

        generateButton.addEventListener('click', async () => {
            if (!API_KEY) {
                showMessage("API Key is missing. Please set your new API key.", 'error');
                return;
            }
            if (!isAuthReady) {
                showMessage("Database status unknown. Please wait a moment.", 'error');
                return;
            }

            showMessage("Generating report... Analyzing images and searching knowledge base.", 'info');
            generateButton.disabled = true;
            // claudeButton.disabled = true; // REMOVED
            downloadButton.classList.add('hidden');
            reportContainer.style.display = 'none';
            
            let retries = 0;
            const MAX_RETRIES = 3;
            let originalFiles = [...selectedFiles]; // Preserve original files for preview until success

            // Function to reset UI and clear resources
            const resetUIAndResources = async () => {
                selectedFiles = [];
                fileInput.value = '';
                showPreviews();
                toggleGenerateButton();
                // Mandatory short delay (500ms) to allow resources to clear before next run
                await new Promise(res => setTimeout(res, 500));
            }


            async function callApiWithRetry() {
                let currentFiles = originalFiles;
                try {
                    // --- 1. Resizing and Preparation ---
                    showMessage("Step 1/3: Resizing and preparing images for analysis...", 'info');
                    const resizedFiles = await Promise.all(currentFiles.map(file => resizeImage(file)));
                    
                    const base64Images = await Promise.all(
                        resizedFiles.map(file => {
                            return new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onloadend = () => {
                                    const dataUrl = reader.result;
                                    const base64 = dataUrl.split(',')[1];
                                    const mimeType = dataUrl.split(',')[0].split(':')[1].split(';')[0];
                                    resolve({ data: base64, mimeType: mimeType });
                                };
                                reader.onerror = reject;
                                reader.readAsDataURL(file);
                            });
                        })
                    );

                    // --- 2. API Call Setup ---
                    showMessage("Step 2/3: Sending request to image analysis model...", 'info');
                    const userNotes = notesInput.value.trim();
                    
                    // --- UPDATED PROMPT FOR STABILITY ---
                    const reportPrompt = `
You are a firearms historian and appraiser specializing in dealer trade-in valuations. Your task is to identify the firearm from the provided photos and create a concise, professional report.
Return ONLY valid JSON with the following structure. Do NOT include any source citations or notations in the text, such as [1], [2], etc.
{
  "modelGuess": "string",
  "identification": "string",
  "productionEra": "string",
  "features": "string",
  "history": "string",
  "conditionNotes": "string",
  "disclaimer": "string",
  "valuation": {
    "wholesaleValueEstimateUSD": "string",
    "valuationConfidence": "string" 
  }
}
CRITICAL: You must provide a clear single numerical value for "wholesaleValueEstimateUSD" (e.g., "500") without dollar signs or ranges. This must be the lowest fair market trade-in price for the firearm's exact condition.
- Identify the firearm model, caliber, and key markings.
- Provide a brief historical context for the model (History field).
- Provide a brief note on the firearm's condition as seen in the photos (ConditionNotes field).
- Include a safety disclaimer in the 'disclaimer' field.
- For "valuationConfidence", rate your confidence (e.g., "High", "Medium", "Low").
`;
                    // --- END UPDATED PROMPT ---

                    const payload = {
                        contents: [{
                            parts: [
                                { text: reportPrompt },
                                { text: `User Notes: ${userNotes}` },
                                ...base64Images.map(img => ({
                                    inlineData: {
                                        mimeType: img.mimeType,
                                        data: img.data
                                    }
                                }))
                            ]
                        }],
                        // --- GOOGLE SEARCH TOOL COMMENTED OUT FOR STABILITY ---
                        // tools: [{ "google_search": {} }],
                    };
                    
                    // --- MODEL NAME FIX APPLIED HERE: gemini-2.5-flash ---
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    // --- 3. Response Handling ---

                    if (!response.ok) {
                        const errorText = await response.text();
                        if (response.status === 503 && retries < MAX_RETRIES) {
                            retries++;
                            showMessage(`Model overloaded. Retrying... (${retries}/${MAX_RETRIES})`, 'info');
                            await new Promise(res => setTimeout(res, 2000 * retries));
                            // Exponential backoff
                            return callApiWithRetry();
                        }
                        throw new Error(`API Error: ${response.status} - ${errorText}`);
                    }

                    const result = await response.json();
                    let jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (!jsonText) {
                         // --- LOGGING for diagnosis ---
                         console.error("API response was empty or did not contain expected text part:", result);
                         throw new Error("Model returned empty or invalid response structure. This is often caused by image processing failure.");
                         // --- END LOGGING ---
                    }
                    
                    // --- Extract grounding sources (for Sources Page) ---
                    // NOTE: Since the tool is disabled, this section will always yield an empty source list.
                    let sources = [];
                    const groundingMetadata = result.candidates[0].groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                    // --- End Source Extraction ---


                    // --- JSON Parsing Fix (Robustness) ---
                    const jsonMatch = jsonText.match(/```json\n([\s\S]*?)\n```/);
                    let report;

                    if (jsonMatch) {
                        jsonText = jsonMatch[1].trim();
                    } else {
                        jsonText = jsonText.trim();
                        const firstBrace = jsonText.indexOf('{');
                        const lastBrace = jsonText.lastIndexOf('}');
                        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                            jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                        }
                    }

                    try {
                        report = JSON.parse(jsonText);
                    } catch (e) {
                        console.error("Failed to parse cleaned JSON:", jsonText);
                        throw new Error(`JSON parsing failed after model response. Possible malformed data returned by the LLM.`);
                    }
                    // --- End JSON Parsing Fix ---

                    // Store the report data globally
                    reportData = report;
                    // Add sources to the report data structure
                    reportData.sources = sources;

                    // --- Custom Calculation: Retail Price (Markup Calculation) ---
                    const wholesaleValueStr = report.valuation.wholesaleValueEstimateUSD.replace(/[$,]/g, '').trim();
                    let wholesaleValue = 0;
                    // NOTE: The model must now generate a valuation based only on its internal knowledge and image analysis.
                    if (wholesaleValueStr.includes('-')) {
                        const parts = wholesaleValueStr.split('-').map(p => parseFloat(p.trim()));
                        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                             wholesaleValue = (parts[0] + parts[1]) / 2;
                            console.warn("LLM returned a range, averaging for wholesale value calculation.");
                        }
                    } else {
                        wholesaleValue = parseFloat(wholesaleValueStr);
                    }
                    
                    let dealerPurchasePrice = 'N/A';
                    let projectedRetailPrice = 'N/A';
                    
                    // Apply price adjustment
                    const adjustedWholesaleValue = wholesaleValue * (1 - PRICE_ADJUSTMENT_PERCENTAGE);
                    if (!isNaN(adjustedWholesaleValue) && adjustedWholesaleValue > 0) {
                        // Dealer Purchase Offer is the ADJUSTED wholesale value
                        dealerPurchasePrice = adjustedWholesaleValue.toFixed(2);
                        // Projected Retail is the ADJUSTED wholesale value marked up (wholesale / 0.65)
                        let retailCalculation = adjustedWholesaleValue / 0.65;
                        // Apply rounding to nearest $5
                        let roundedRetail = roundUpToNearestFive(retailCalculation);
                        projectedRetailPrice = roundedRetail.toFixed(2); 

                        // Store the calculated prices for saving to Firestore
                        report.valuation.dealerPurchasePriceUSD = dealerPurchasePrice;
                        report.valuation.projectedRetailPriceUSD = projectedRetailPrice;
                    }
                    
                    // --- Display Report ---
                    reportContent.innerHTML = '';
                    reportContent.innerHTML += `<div class="p-4 bg-gray-50 rounded-lg">
                        <p class="font-bold">Model:</p>
                        <p>${report.modelGuess}</p>
                    </div>`;
                    reportContent.innerHTML += `<div>
                        <h3 class="font-semibold text-lg text-gray-800">Identification</h3>
                        <p class="text-gray-700">${report.identification}</p>
                    </div>`;
                    reportContent.innerHTML += `<div>
                        <h3 class="font-semibold text-lg text-gray-800">Production Era</h3>
                        <p class="text-gray-700">${report.productionEra}</p>
                    </div>`;
                    reportContent.innerHTML += `<div>
                        <h3 class="font-semibold text-lg text-gray-800">Features</h3>
                        <p class="text-gray-700">${report.features}</p>
                    </div>`;
                    reportContent.innerHTML += `<div>
                        <h3 class="font-semibold text-lg text-gray-800">History</h3>
                        <p class="text-gray-700">${report.history}</p>
                    </div>`;
                    // Display new streamlined valuation and confidence
                    let valuationHtml = `<div>
                        <h3 class="font-semibold text-lg text-gray-800">Valuation</h3>
                        <div class="mt-2 space-y-3 p-4 border rounded-xl bg-green-50">
                            <div class="flex justify-between font-medium text-gray-700">
                                <span class="text-blue-700">Dealer Purchase Offer:</span>
                                <span class="text-blue-700 font-bold no-break">$${dealerPurchasePrice}</span>
                            </div>
                            <div class="flex justify-between font-medium text-gray-700 border-t pt-3 mt-3">
                                <span>Projected Retail Value:</span>
                                <span class="text-green-700 font-bold no-break">$${projectedRetailPrice}</span>
                            </div>
                        </div>
                        <div class="mt-4 text-sm text-gray-600">
                            <strong>Confidence Level:</strong> 
                            <span class="font-semibold text-gray-800">${report.valuation.valuationConfidence}</span>
                            <p class="text-xs mt-1">This reflects the estimated certainty based on image clarity and market 
                            data availability.</p>
                        </div>
                        <p class="mt-2 text-xs text-gray-500">
                            *Valuation methodology and source details are included on the final page of the downloadable PDF report.
                            </p>
                    </div>`;
                    reportContent.innerHTML += valuationHtml;
                    
                    reportContent.innerHTML += `<div>
                        <h3 class="font-semibold text-lg text-gray-800">Condition</h3>
                        <p class="text-gray-700">${report.conditionNotes}</p>
                    </div>`;
                    reportContent.innerHTML += `<div class="p-4 mt-4 bg-yellow-50 text-sm text-yellow-800 rounded-lg">
                        <p><strong>Disclaimer:</strong> ${report.disclaimer}</p>
                    </div>`;
                    reportContainer.style.display = 'block';
                    downloadButton.classList.remove('hidden');
                    showMessage("Report generated successfully! (Step 3/3 complete)", 'info');

                    // --- Save to Firestore ---
                    if (isAuthReady && db) {
                        const reportRef = doc(db, `artifacts/${appId}/users/${userId}/reports/${Date.now()}`);
                        await setDoc(reportRef, report);
                        console.log("Report saved to Firestore.");
                    }
                } catch (error) {
                    console.error("Report generation error:", error);
                    showMessage(`Failed to generate report: ${error.message}`, 'error');
                } finally {
                    // --- Final cleanup after success or failure ---
                    await resetUIAndResources();
                    generateButton.disabled = false;
                }
            }
            callApiWithRetry();
        });

        downloadButton.addEventListener('click', async () => {
            const { jsPDF } = window.jspdf;
            const reportElement = document.getElementById('report-container');
            
            showMessage("Preparing PDF for download...", 'info');
            downloadButton.disabled = true;

            // --- Footer Function ---
            const addFooter = (doc, margin, pageHeight) => {
                doc.setFontSize(8);
                doc.setTextColor(150); // Gray color
                doc.setFont("helvetica", "normal"); // Use a standard font that is guaranteed to exist
                const footerText = "WWW.Ludditelearning.com";
                // Position 5mm from the bottom (pageHeight - 5)
                const footerY = pageHeight - 5; 
                doc.text(footerText, margin, footerY);
            };

            try {
                
                // Get the model guess and sanitize it
                const modelGuess = reportData?.modelGuess || 'Unknown_Model';
                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                const sanitizedFilename = modelGuess.replace(/[/\s]+/g, '_') + '_' + dateString + '_Report.pdf';
                const doc = new jsPDF('p', 'mm', 'a4');
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 10;
                // Reduced margin for more space

                // 1. Add Report Content (Page 1)
                const reportCanvas = await html2canvas(reportElement, { 
                    scale: 3,
                    width: reportElement.offsetWidth 
                }); 
                const reportImgData = reportCanvas.toDataURL('image/jpeg', 1.0);
                const reportWidth = reportCanvas.width;
                const reportHeight = reportCanvas.height;
                const reportRatio = reportWidth / reportHeight;
                const reportPdfWidth = pageWidth - margin * 2;
                const reportPdfHeight = reportPdfWidth / reportRatio;

                let currentYPos = margin;
                // Add main report image
                doc.addImage(reportImgData, 'JPEG', margin, currentYPos, reportPdfWidth, reportPdfHeight);
                currentYPos += reportPdfHeight + 5; // Add vertical spacing

                // *********** FIX: Footer added after main content ***********
                addFooter(doc, margin, pageHeight);
                // ************************************************************


                // 2. Add Images (Starting on a new page if necessary, or continuing Page 1)
                if (selectedFiles.length > 0) {
                    
                    // --- Reference Title Logic ---
                    
                    // Estimate the space needed for the image title text (approx 8mm height)
                    const titleHeight = 8;
                    // Check if we have space for the title AND the first image block (approx 150mm for first image row)
                    const requiredSpace = titleHeight + 75;
                    // Title + 1/2 page column height estimate

                    if (currentYPos > pageHeight - margin - requiredSpace) { 
                        // If there is not enough space, start a new page for the title
                        doc.addPage();
                        currentYPos = margin;
                        
                        // Print title at the start of the new page
                        doc.setFontSize(16);
                        doc.setTextColor(0); // Reset color to black for text
                        doc.text("Reference Images", margin, currentYPos);
                        currentYPos += titleHeight; // Advance past the title
                        
                        // *********** FIX: Footer added immediately after new page ***********
                        addFooter(doc, margin, pageHeight);
                        // *******************************************************************
                    } else {
                        // Print title on the current page if there is space
                        doc.setFontSize(16);
                        doc.setTextColor(0); // Reset color to black for text
                        doc.text("Reference Images", margin, currentYPos);
                        currentYPos += titleHeight; // Advance past the title
                    }

                    // --- End Reference Title Logic ---


                    const imagePadding = 5;
                    // Space between images
                    // Set image width to 45% of the page width (allowing two columns)
                    const singleImgWidth = (pageWidth - margin * 2 - imagePadding) / 2;
                    let rowMaxHeight = 0;
                    
                    for (let i = 0; i < originalFiles.length; i++) { // Use originalFiles for PDF generation
                        const file = originalFiles[i];
                        const reader = new FileReader();
                        reader.readAsDataURL(file);
                        await new Promise(resolve => reader.onloadend = resolve);
                        
                        const imgDataUrl = reader.result;
                        const img = new Image();
                        img.src = imgDataUrl;
                        await new Promise(resolve => img.onload = resolve);
                        const imgRatio = img.width / img.height;
                        const imgPdfHeight = singleImgWidth / imgRatio;
                        
                        // Check if we are starting a new row (i is even)
                        if (i % 2 === 0) {
                            // Advance Y position based on the height of the *previous* completed row
                            currentYPos += rowMaxHeight + (i > 0 ? imagePadding : 0);
                            rowMaxHeight = 0; // Reset max height for the new row

                            // Page break check for the new row start (allowing room for image + footer)
                            if (currentYPos + imgPdfHeight > pageHeight - margin - 10) { // -10 to leave room for footer
                                doc.addPage();
                                currentYPos = margin;
                                
                                // Print continuation title at the start of the new page
                                doc.setFontSize(16);
                                doc.text("Reference Images (Cont.)", margin, currentYPos);
                                currentYPos += titleHeight; // Advance past the title

                                // *********** FIX: Footer added immediately after new page ***********
                                addFooter(doc, margin, pageHeight);
                                // *******************************************************************
                            }
                        }

                        // Determine image placement coordinates
                        const currentXPos = (i % 2 === 0) ?
                        margin : margin + singleImgWidth + imagePadding;
                        const imageYPos = currentYPos;
                        // Y position is set when the row starts

                        // Track the maximum height in the current row for correct spacing of the next row
                        rowMaxHeight = Math.max(rowMaxHeight, imgPdfHeight);
                        // Add image
                        doc.addImage(imgDataUrl, 'JPEG', currentXPos, imageYPos, singleImgWidth, imgPdfHeight);
                    }
                }
                
                // 3. Add Valuation Methodology and Sources Page (Page 3 or later)
                const methodologyTitle = "Valuation Methodology and Sources";
                // NOTE: The methodology text has been updated to reflect the disabled search tool.
                const methodologyText = `
The final retail valuation is determined using a two-step process:

1. Wholesale/Purchase Offer: The 'Dealer Purchase Offer' is the Wholesale/Dealer Acquisition Price provided by the Large Language Model (LLM) based on its internal knowledge base.
The confidence level reflects the model's certainty in this estimate.
2. Projected Retail Value: This value is calculated by applying a standard industry markup to the Purchase Offer (Wholesale Price / 0.65).
The resulting figure is then rounded up to the nearest $5.00 to reflect typical retail pricing practices.
The following online sources were referenced by the LLM in real-time to generate the identification details and the estimated wholesale price:
`;
                let sourceList = reportData.sources || [];
                
                // If no specific sources are returned by the LLM, add a generic entry.
                if (sourceList.length === 0) {
                    sourceList.push({
                        title: "General Market Data (Aggregated by LLM)",
                        uri: "Valuation synthesized from publicly available auction, retail, and wholesale pricing data found via internal model knowledge."
                    });
                }

                // Always add a new page for the Sources/Methodology
                doc.addPage();
                currentYPos = margin;
                
                // Print Title
                doc.setFontSize(16);
                doc.setTextColor(0);
                doc.text(methodologyTitle, margin, currentYPos);
                currentYPos += 10;

                // Print Methodology Text (Using splitTextToSize for auto-wrapping)
                doc.setFontSize(10);
                doc.setTextColor(50);
                doc.setFont("helvetica", "normal");
                const reportPdfWidthMethodology = pageWidth - margin * 2;
                let textLines = doc.splitTextToSize(methodologyText, reportPdfWidthMethodology);
                doc.text(textLines, margin, currentYPos);
                currentYPos += textLines.length * 4.5; // Adjusted line height (was 5) for better spacing

                // Print Sources
                doc.setFontSize(10);
                doc.setTextColor(50);
                doc.setFont("helvetica", "bold");
                doc.text("Referenced Sources:", margin, currentYPos);
                currentYPos += 5;

                doc.setFont("helvetica", "normal");
                doc.setFontSize(9);
                sourceList.forEach((source, index) => {
                    const sourceText = `${index + 1}. ${source.title} (${source.uri})`;
                    // Split long lines/URLs to fit within the width
                    let sourceLines = doc.splitTextToSize(sourceText, reportPdfWidthMethodology);

                    // Check for page overflow
                    if (currentYPos + sourceLines.length * 4.5 > pageHeight - margin - 10) {
                        doc.addPage();
                        currentYPos = margin;
                        
                        // Print continuation title if needed
                        doc.setFontSize(10);
                        doc.text("Sources (Cont.):", margin, currentYPos);
                        currentYPos += 5;

                        // *********** FIX: Footer added immediately after new page ***********
                        addFooter(doc, margin, pageHeight);
                        // *******************************************************************
                    }

                    doc.text(sourceLines, margin, currentYPos);
                    currentYPos += sourceLines.length * 4.5; // Advance Y position (approx 4.5mm per line)
                });
                // *********** FIX: Footer added after methodology and source listing ***********
                addFooter(doc, margin, pageHeight);
                // ******************************************************************************

                doc.save(sanitizedFilename);
                showMessage("PDF download started!", 'info');
            } catch (error) {
                console.error("PDF generation failed:", error);
                showMessage("Failed to generate PDF. Please try again.", 'error');
            } finally {
                downloadButton.disabled = false;
            }
        });
    </script>
</body>
</html>