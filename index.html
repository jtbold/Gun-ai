<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firearm Report Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Libraries for PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            /* Ensures the container is full width on small screens, max 800px on desktop */
            width: 95%; 
            max-width: 800px;
        }
        /* Custom styling for the report header to ensure the logo looks clean */
        #report-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 1rem;
        }
        /* Styling to prevent line breaking on valuation numbers */
        .no-break {
            white-space: nowrap;
        }
        /* NEW: Styling for file input to overlay the button for reliable mobile tapping */
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        .file-input-wrapper input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center">
    <!-- Main Application Container -->
    <div class="container bg-white rounded-3xl shadow-xl p-4 sm:p-8 space-y-8">
        <header class="text-center">
            <!-- Dealer Logo Placeholder -->
            <h2 id="cabelas-logo" class="mx-auto text-yellow-600 text-3xl font-bold mb-4">Dealer Logo</h2>
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">Firearm Report Generator</h1>
            <p class="text-gray-500">Upload, paste, or drag and drop photos to identify your firearm and generate a report.</p>
            <p id="user-id" class="text-xs text-gray-400 mt-2"></p>
        </header>
        <!-- Image Upload/Paste Area -->
        <div id="drop-zone" class="w-full rounded-2xl border-4 border-dashed border-gray-300 p-8 text-center transition-colors hover:border-gray-400">
            <div class="text-lg font-medium text-gray-700">Drag & drop, paste (Ctrl+V), or click to upload images</div>
            <p class="text-sm text-gray-400 mt-2">Maximum of 6 images, up to 4MB each. JPG and PNG are preferred.</p>
            <!-- File input is wrapped to overlay the button -->
            <div class="file-input-wrapper mt-6">
                <input type="file" id="file-input" accept="image/*" multiple>
                <button id="upload-button" class="px-6 py-3 bg-gray-900 text-white font-semibold rounded-xl hover:bg-gray-700 transition-colors pointer-events-none">
                    Choose Images
                </button>
            </div>
        </div>
        <!-- URL Input Section -->
        <div class="w-full">
            <div class="flex flex-col gap-3">
                <label for="url-input" class="text-sm font-medium text-gray-700">To add images from the internet, find an image, right-click it, and select "Copy Image Address". Then paste the URL below.</label>
                <div class="flex items-center gap-3">
                    <input type="text" id="url-input" placeholder="Paste image URL here..." class="flex-grow rounded-xl p-3 border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <button id="url-button" class="px-6 py-3 bg-gray-900 text-white font-semibold rounded-xl hover:bg-gray-700 transition-colors">
                        Add from URL
                    </button>
                </div>
            </div>
        </div>
        
        <!-- User Notes Section -->
        <div class="w-full">
            <div class="flex flex-col gap-3">
                <label for="notes-input" class="text-sm font-medium text-gray-700">Optional notes for identification (e.g., serial numbers, specific markings, history):</label>
                <textarea id="notes-input" rows="3" class="rounded-xl p-3 border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
            </div>
        </div>
        <!-- Image Previews -->
        <div id="image-previews" class="flex flex-wrap gap-4 justify-center items-center p-4 rounded-xl bg-gray-50 shadow-inner" style="display: none;"></div>
        <!-- Action Button and Status -->
        <div class="flex flex-col items-center justify-center space-y-4">
            <button id="generate-button" class="w-full px-8 py-4 bg-indigo-600 text-white font-bold text-lg rounded-2xl shadow-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Generate Report
            </button>
            <button id="download-button" class="w-full px-8 py-4 bg-gray-500 text-white font-bold text-lg rounded-2xl shadow-lg hover:bg-gray-600 transition-colors hidden">
                Download Report
            </button>
            <div id="status-message" class="text-sm text-center text-gray-600"></div>
        </div>
        <!-- Report Display Section -->
        <div id="report-container" class="w-full bg-white rounded-2xl shadow-lg p-6 space-y-6" style="display: none;">
            <!-- Report Header with Logo Placeholder for PDF generation -->
            <div id="report-header">
                <h3 class="text-xl font-bold text-yellow-600 mx-auto mb-2">Dealer Logo</h3>
                <h2 class="text-2xl font-bold text-gray-900">Firearm Identification Report</h2>
            </div>
            <div id="report-content" class="space-y-4"></div>
        </div>
    </div>
    <!-- Firebase Scripts and Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        document.addEventListener('DOMContentLoaded', () => {
            // Global variables provided by the environment
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            
            // *** CRITICAL FIX: Get the API key from the environment variable exposed by Vite ***
            // The key is now guaranteed to be found here if the build step succeeded.
            const API_KEY = import.meta.env.VITE_API_KEY || ""; 
            
            // --- Pricing Rule Parameters ---
            const LOW_VALUE_THRESHOLD = 200.00; // Wholesale value at or below this triggers special rule
            const RETAIL_MARKUP_DIVISOR = 0.65; // Base retail calculation: Wholesale / 0.65 (approx 35% GM)
            const LOW_VALUE_RETAIL_OFFER_PERCENT = 0.50; // New rule: DPO = Retail * 0.50
            
            let reportData = null; // Variable to hold the report data
            // --- Firebase Initialization ---
            let app, db, auth, userId;
            let isAuthReady = false;
            
            async function initFirebase() {
                try {
                    if (Object.keys(firebaseConfig).length === 0) {
                        console.warn("Firebase configuration is missing. Running in local mode without persistence.");
                        isAuthReady = true; 
                        userId = crypto.randomUUID();
                        document.getElementById('user-id').textContent = `User ID: (Local) ${userId.substring(0, 8)}...`;
                        return;
                    }
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser.uid;
                    document.getElementById('user-id').textContent = `User ID: ${userId}`;
                    isAuthReady = true;
                    console.log("Firebase initialized successfully.");
                } catch (error) {
                    console.error("Firebase initialization error:", error);
                    document.getElementById('status-message').textContent = "Failed to connect to the database. Some features may not work.";
                }
            }
            initFirebase();
            // --- DOM Elements ---
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const urlInput = document.getElementById('url-input');
            const urlButton = document.getElementById('url-button');
            const notesInput = document.getElementById('notes-input');
            const generateButton = document.getElementById('generate-button');
            const downloadButton = document.getElementById('download-button');
            const imagePreviewsContainer = document.getElementById('image-previews');
            const statusMessage = document.getElementById('status-message');
            const reportContainer = document.getElementById('report-container');
            const reportContent = document.getElementById('report-content');
            let selectedFiles = [];
            const MAX_FILES = 6;
            const MAX_FILE_SIZE_MB = 4;
            
            // List of unsupported MIME types for the current Gemini Vision model
            const UNSUPPORTED_MIME_TYPES = ['image/avif', 'image/svg+xml'];
            // --- Utility Functions ---
            /** Rounds a number up to the nearest multiple of 5. */
            function roundUpToNearestFive(num) {
                if (isNaN(num) || num <= 0) return 0;
                return Math.ceil(num / 5) * 5;
            }
            function showMessage(message, type = 'info') {
                statusMessage.className = `text-sm text-center mt-4 ${type === 'error' ? 'text-red-600' : 'text-gray-600'}`;
                statusMessage.textContent = message;
            }
            function toggleGenerateButton() {
                generateButton.disabled = selectedFiles.length === 0;
                if (selectedFiles.length === 0) {
                    downloadButton.classList.add('hidden');
                }
            }
            function showPreviews() {
                imagePreviewsContainer.innerHTML = '';
                if (selectedFiles.length > 0) {
                    imagePreviewsContainer.style.display = 'flex';
                    selectedFiles.forEach((file, index) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const imgWrapper = document.createElement('div');
                            imgWrapper.className = 'relative group w-32 h-32 rounded-lg overflow-hidden shadow-md';
                            imgWrapper.innerHTML = `
                                <img src="${e.target.result}" alt="Preview ${index + 1}" class="w-full h-full object-cover">
                                <!-- Mobile Optimization: Increased touch target size for removal -->
                                <button class="absolute top-0 right-0 bg-black/70 text-white rounded-full p-2 leading-none text-base opacity-0 group-hover:opacity-100 transition-opacity transform translate-x-1 -translate-y-1" data-index="${index}">
                                    &times;
                                </button>
                            `;
                            imagePreviewsContainer.appendChild(imgWrapper);
                        };
                        reader.readAsDataURL(file);
                    });
                } else {
                    imagePreviewsContainer.style.display = 'none';
                }
            }
            
            function processFiles(files) {
                console.log(`Processing ${files.length} new file(s) for upload.`); // Diagnostic log
                
                let newFiles = Array.from(files).filter(file => {
                    const mimeType = file.type.toLowerCase();
                    
                    if (!mimeType.startsWith('image/')) {
                        showMessage(`File "${file.name}" is not an image.`, 'error');
                        return false;
                    }
                    
                    // Explicitly check for unsupported MIME types
                    if (UNSUPPORTED_MIME_TYPES.includes(mimeType)) {
                         showMessage(`File "${file.name}" uses an unsupported image format (${file.type}). Please use JPG or PNG.`, 'error');
                         return false;
                    }
                    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                        showMessage(`File "${file.name}" exceeds the ${MAX_FILE_SIZE_MB}MB size limit.`, 'error');
                        return false;
                    }
                    return true;
                });
                if (selectedFiles.length + newFiles.length > MAX_FILES) {
                    const limit = MAX_FILES - selectedFiles.length;
                    newFiles = newFiles.slice(0, limit);
                    showMessage(`Maximum image limit reached. Added ${limit} new files. Total: ${MAX_FILES}/${MAX_FILES}`, 'error');
                }
                selectedFiles = [...selectedFiles, ...newFiles].slice(0, MAX_FILES);
                showPreviews();
                toggleGenerateButton();
                if (newFiles.length > 0) {
                    showMessage(`Added ${newFiles.length} files. Total: ${selectedFiles.length}/${MAX_FILES}`);
                }
            }
            // --- Event Listeners ---
            fileInput.addEventListener('change', (e) => {
                console.log('*** FILE CHANGE EVENT TRIGGERED ***'); // Diagnostic log
                processFiles(e.target.files);
                e.target.value = ''; // Clear input for next selection
            });
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('border-gray-500', 'bg-gray-50');
            });
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('border-gray-500', 'bg-gray-50');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('border-gray-500', 'bg-gray-50');
                processFiles(e.dataTransfer.files);
            });
            window.addEventListener('paste', (e) => {
                const items = e.clipboardData.items;
                let files = [];
                for (let i = 0; i < items.length; i++) {
                    if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                        const file = items[i].getAsFile();
                        files.push(file);
                    }
                }
                if (files.length > 0) {
                    processFiles(files);
                }
            });
            
            urlButton.addEventListener('click', async () => {
                const url = urlInput.value.trim();
                if (!url) {
                    showMessage('Please enter a valid image URL.', 'error');
                    return;
                }
                if (selectedFiles.length >= MAX_FILES) {
                    showMessage(`You have reached the maximum of ${MAX_FILES} images.`, 'error');
                    return;
                }
                // Simple validation for common image extensions
                if (!url.match(/\.(jpeg|jpg|gif|png|webp|svg|avif)$/i)) { // Added avif here to catch it before fetching
                     showMessage('The URL does not look like a direct image link (e.g., must end in .jpg).', 'error');
                     return;
                }
                
                showMessage('Fetching image from URL... This might fail due to Cross-Origin (CORS) policies.', 'info');
                urlButton.disabled = true;
                try {
                    // Using a proxy might be necessary for CORS, but we rely on the browser's native fetch.
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const contentType = response.headers.get('Content-Type')?.toLowerCase();
                    
                    if (!contentType || !contentType.startsWith('image/')) {
                        throw new Error(`URL did not return an image. Content-Type: ${contentType}`);
                    }
                    
                    // Explicit check for unsupported MIME types retrieved from header
                    if (UNSUPPORTED_MIME_TYPES.includes(contentType)) {
                         showMessage(`Image from URL uses an unsupported format (${contentType}). Please use JPG or PNG.`, 'error');
                         return;
                    }
                    const blob = await response.blob();
                    
                    // Create a File object from the Blob
                    const filename = url.substring(url.lastIndexOf('/') + 1) || 'image';
                    const file = new File([blob], filename, { type: blob.type });
                    
                    // Manually check size, as processFiles relies on file object properties
                    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                        showMessage(`Image from URL exceeds the ${MAX_FILE_SIZE_MB}MB size limit.`, 'error');
                    } else {
                        processFiles([file]);
                        urlInput.value = '';
                        showMessage('Image added successfully from URL.');
                    }
                } catch (error) {
                    console.error(error);
                    showMessage(`Failed to load image from URL: ${error.message}. This may be due to a Cross-Origin Resource Sharing (CORS) policy.`, 'error');
                } finally {
                    urlButton.disabled = false;
                }
            });
            imagePreviewsContainer.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    const index = e.target.getAttribute('data-index');
                    selectedFiles.splice(index, 1);
                    showPreviews();
                    toggleGenerateButton();
                    showMessage(`Removed image ${parseInt(index) + 1}.`);
                }
            });
            // --- LLM and Report Generation ---
            generateButton.addEventListener('click', async () => {
                if (!API_KEY) {
                    showMessage("API Key is missing. Cannot generate report.", 'error');
                    return;
                }
                if (!isAuthReady) {
                    showMessage("Database status unknown. Please wait a moment.", 'error');
                    return;
                }
                showMessage("Generating report... Analyzing images and searching knowledge base.", 'info');
                generateButton.disabled = true;
                downloadButton.classList.add('hidden');
                reportContainer.style.display = 'none';
                
                let retries = 0;
                const MAX_RETRIES = 3;
                async function callApiWithRetry() {
                    try {
                        const base64Images = await Promise.all(
                            selectedFiles.map(file => {
                                return new Promise((resolve, reject) => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => {
                                        // Resolve with only the base64 data part (after the comma)
                                        const dataUrl = reader.result;
                                        const base64 = dataUrl.split(',')[1];
                                        const mimeType = dataUrl.split(',')[0].split(':')[1].split(';')[0];
                                        resolve({ data: base64, mimeType: mimeType });
                                    };
                                    reader.onerror = reject;
                                    reader.readAsDataURL(file);
                            });
                        })
                        );
                        const userNotes = notesInput.value.trim();
                        
                        // IMPORTANT: We now ask for the WHOLESALE (Trade-in) value, and the application calculates the Retail Price
                        const reportPrompt = `
You are a firearms historian and appraiser specializing in dealer trade-in valuations. Your task is to identify the firearm from the provided photos and create a concise, professional report.
Use the provided user notes and the images and external knowledge for accuracy.
Return ONLY valid JSON with the following structure. Do NOT include any source citations or notations in the text, such as [1], [2], etc.
{
  "modelGuess": "string",
  "identification": "string",
  "productionEra": "string",
  "features": "string",
  "history": "string",
  "conditionNotes": "string",
  "disclaimer": "string",
  "valuation": {
    "wholesaleValueEstimateUSD": "string",
    "valuationConfidence": "string" 
  }
}
- Identify the firearm model, caliber, and key markings. If the information is unclear from the images, state this.
- If user notes are provided, incorporate them into the report's identification and condition notes as relevant.
- Estimate the production era based on visible features (e.g., markings, finish, stock type).
- Describe the key features visible in the photos.
- Provide a brief historical context for the model.
- Provide a SINGLE wholesale/dealer acquisition value in USD based on the condition observed in the photos. This price should represent the **lowest fair market value (trade-in price)** for a rifle in this exact condition, factoring in typical wear and potential hidden issues. **You must specifically look for trade-in price data from reliable sources, NOT high collector retail prices.** Do not include dollar signs, just the single numerical value (e.g., "500"). You must provide a clear single number, not a range.
- Provide a brief note on the firearm's condition as seen in the photos.
- Include a safety disclaimer in the 'disclaimer' field stating this is not a legal appraisal and to always handle firearms safely.
- For "valuationConfidence", rate your confidence in the trade-in value estimate based on the clarity of the photos and market data availability (e.g., "High", "Medium", "Low").
`;
                        const payload = {
                            contents: [{
                                parts: [
                                    { text: reportPrompt },
                                    { text: `User Notes: ${userNotes}` },
                                    ...base64Images.map(img => ({
                                        inlineData: {
                                            mimeType: img.mimeType,
                                            data: img.data
                                        }
                                    }))
                                ]
                            }],
                            tools: [{ "google_search": {} }],
                        };
                        
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
                        
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!response.ok) {
                            const errorText = await response.text();
                            if (response.status === 503 && retries < MAX_RETRIES) {
                                retries++;
                                showMessage(`Model overloaded. Retrying... (${retries}/${MAX_RETRIES})`, 'info');
                                await new Promise(res => setTimeout(res, 2000 * retries)); // Exponential backoff
                                return callApiWithRetry();
                            }
                            throw new Error(`API Error: ${response.status} - ${errorText}`);
                        }
                        const result = await response.json();
                        let jsonText = result.candidates[0].content.parts[0].text;
                        
                        // --- Extract grounding sources (for Sources Page) ---
                        let sources = [];
                        const groundingMetadata = result.candidates[0].groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title); // Ensure sources are valid
                        }
                        // --- End Source Extraction ---
                        // --- JSON Parsing Fix (Robustness) ---
                        const jsonMatch = jsonText.match(/```json\n([\s\S]*?)\n```/);
                        let report;
                        if (jsonMatch) {
                            jsonText = jsonMatch[1].trim();
                        } else {
                            jsonText = jsonText.trim();
                            const firstBrace = jsonText.indexOf('{');
                            const lastBrace = jsonText.lastIndexOf('}');
                            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                                jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                            }
                        }
                        try {
                            report = JSON.parse(jsonText);
                        } catch (e) {
                            console.error("Failed to parse cleaned JSON:", jsonText);
                            throw new Error(`JSON parsing failed after model response. Possible malformed data returned by the LLM.`);
                        }
                        // --- End JSON Parsing Fix ---
                        // Store the report data globally
                        reportData = report;
                        
                        // Add sources to the report data structure
                        reportData.sources = sources; // Store extracted sources
                        // --- Custom Calculation: Retail Price (Markup Calculation) ---
                        const wholesaleValueStr = report.valuation.wholesaleValueEstimateUSD.replace(/[$,]/g, '').trim(); 
                        
                        let wholesaleValue = 0;
                        if (wholesaleValueStr.includes('-')) {
                            const parts = wholesaleValueStr.split('-').map(p => parseFloat(p.trim()));
                            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                                 wholesaleValue = (parts[0] + parts[1]) / 2;
                                 console.warn("LLM returned a range, averaging for wholesale value calculation.");
                            }
                        } else {
                            wholesaleValue = parseFloat(wholesaleValueStr);
                        }
                        
                        let dealerPurchasePrice = 'N/A';
                        let projectedRetailPrice = 'N/A';
                        
                        // The base DPO is the wholesale value (no general adjustment)
                        let baseDPO = wholesaleValue;
                        
                        if (!isNaN(wholesaleValue) && wholesaleValue > 0) {
                            
                            // STEP 1: Calculate Projected Retail Price (TRP)
                            // Retail is based on the Wholesale Value marked up (Wholesale / 0.65)
                            let retailCalculation = wholesaleValue / RETAIL_MARKUP_DIVISOR;
                            let roundedRetail = roundUpToNearestFive(retailCalculation);
                            projectedRetailPrice = roundedRetail.toFixed(2);
                            
                            // STEP 2: Apply Conditional DPO Rule
                            // If the base wholesale value is <= $200, apply the special 50% retail rule.
                            if (wholesaleValue <= LOW_VALUE_THRESHOLD) {
                                // DPO = Rounded Retail * 0.50
                                baseDPO = roundedRetail * LOW_VALUE_RETAIL_OFFER_PERCENT;
                                console.log(`Low value item detected ($${wholesaleValue}). Applying 50% retail rule. New DPO: $${baseDPO.toFixed(2)}`);
                            }
                            
                            // Finalize Dealer Purchase Price
                            dealerPurchasePrice = baseDPO.toFixed(2);
                            
                            // Store the calculated prices for saving to Firestore
                            report.valuation.dealerPurchasePriceUSD = dealerPurchasePrice;
                            report.valuation.projectedRetailPriceUSD = projectedRetailPrice;
                        }
                        // --- END ADJUSTED CALCULATION ---
                        
                        // --- Display Report ---
                        reportContent.innerHTML = '';
                        reportContent.innerHTML += `<div class="p-4 bg-gray-50 rounded-lg">
                            <p class="font-bold">Model:</p>
                            <p>${report.modelGuess}</p>
                        </div>`;
                        reportContent.innerHTML += `<div>
                            <h3 class="font-semibold text-lg text-gray-800">Identification</h3>
                            <p class="text-gray-700">${report.identification}</p>
                        </div>`;
                        reportContent.innerHTML += `<div>
                            <h3 class="font-semibold text-lg text-gray-800">Production Era</h3>
                            <p class="text-gray-700">${report.productionEra}</p>
                        </div>`;
                        reportContent.innerHTML += `<div>
                            <h3 class="font-semibold text-lg text-gray-800">Features</h3>
                            <p class="text-gray-700">${report.features}</p>
                        </div>`;
                        reportContent.innerHTML += `<div>
                            <h3 class="font-semibold text-lg text-gray-800">History</h3>
                            <p class="text-gray-700">${report.history}</p>
                        </div>`;
                        // Display new streamlined valuation and confidence
                        let valuationHtml = `<div>
                            <h3 class="font-semibold text-lg text-gray-800">Valuation</h3>
                            <div class="mt-2 space-y-3 p-4 border rounded-xl bg-green-50">
                                <div class="flex justify-between font-medium text-gray-700">
                                    <span class="text-blue-700">Dealer Purchase Offer:</span>
                                    <span class="text-blue-700 font-bold no-break">$${dealerPurchasePrice}</span>
                                </div>
                                <div class="flex justify-between font-medium text-gray-700 border-t pt-3 mt-3">
                                    <span>Projected Retail Value:</span>
                                    <span class="text-green-700 font-bold no-break">$${projectedRetailPrice}</span>
                                </div>
                            </div>
                            <div class="mt-4 text-sm text-gray-600">
                                <strong>Confidence Level:</strong> 
                                <span class="font-semibold text-gray-800">${report.valuation.valuationConfidence}</span>
                                <p class="text-xs mt-1">This reflects the estimated certainty based on image clarity and market data availability.</p>
                            </div>
                            <p class="mt-2 text-xs text-gray-500">
                                *Valuation methodology and source details are included on the final page of the downloadable PDF report.
                            </p>
                        </div>`;
                        reportContent.innerHTML += valuationHtml;
                        
                        reportContent.innerHTML += `<div>
                            <h3 class="font-semibold text-lg text-gray-800">Condition</h3>
                            <p class="text-gray-700">${report.conditionNotes}</p>
                        </div>`;
                        
                        reportContent.innerHTML += `<div class="p-4 mt-4 bg-yellow-50 text-sm text-yellow-800 rounded-lg">
                            <p><strong>Disclaimer:</strong> ${report.disclaimer}</p>
                        </div>`;
                        reportContainer.style.display = 'block';
                        downloadButton.classList.remove('hidden');
                        showMessage("Report generated successfully!");
                        // --- Save to Firestore ---
                        if (isAuthReady && db) {
                            const reportRef = doc(db, `artifacts/${appId}/users/${userId}/reports/${Date.now()}`);
                            await setDoc(reportRef, report);
                            console.log("Report saved to Firestore.");
                        }
                    } catch (error) {
                        console.error("Report generation error:", error);
                        showMessage(`Failed to generate report: ${error.message}`, 'error');
                    } finally {
                        generateButton.disabled = false;
                    }
                }
                callApiWithRetry();
            });
            downloadButton.addEventListener('click', async () => {
                const { jsPDF } = window.jspdf;
                const reportElement = document.getElementById('report-container');
                
                showMessage("Preparing PDF for download...", 'info');
                downloadButton.disabled = true;
                // --- Footer Function ---
                const addFooter = (doc, margin, pageHeight) => {
                    doc.setFontSize(8);
                    doc.setTextColor(150); // Gray color
                    doc.setFont("helvetica", "normal"); // Use a standard font that is guaranteed to exist
                    const footerText = "WWW.Ludditelearning.com";
                    // Position 5mm from the bottom (pageHeight - 5)
                    const footerY = pageHeight - 5; 
                    doc.text(footerText, margin, footerY);
                };
                try {
                    // Get the model guess and sanitize it
                    const modelGuess = reportData?.modelGuess || 'Unknown_Model';
                    const today = new Date();
                    const dateString = today.toISOString().split('T')[0];
                    const sanitizedFilename = modelGuess.replace(/[/\s]+/g, '_') + '_' + dateString + '_Report.pdf';
                    const doc = new jsPDF('p', 'mm', 'a4');
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 10; // Reduced margin for more space
                    // 1. Add Report Content (Page 1)
                    const reportCanvas = await html2canvas(reportElement, { 
                        scale: 3,
                        width: reportElement.offsetWidth 
                    }); 
                    const reportImgData = reportCanvas.toDataURL('image/jpeg', 1.0);
                    const reportWidth = reportCanvas.width;
                    const reportHeight = reportCanvas.height;
                    const reportRatio = reportWidth / reportHeight;
                    const reportPdfWidth = pageWidth - margin * 2;
                    const reportPdfHeight = reportPdfWidth / reportRatio;
                    let currentYPos = margin;
                    // Add main report image
                    doc.addImage(reportImgData, 'JPEG', margin, currentYPos, reportPdfWidth, reportPdfHeight);
                    currentYPos += reportPdfHeight + 5; // Add vertical spacing
                    // Footer added after main content 
                    addFooter(doc, margin, pageHeight);
                    // 2. Add Images (Starting on a new page if necessary, or continuing Page 1)
                    if (selectedFiles.length > 0) {
                        
                        // --- Reference Title Logic ---
                        
                        // Estimate the space needed for the image title text (approx 8mm height)
                        const titleHeight = 8;
                        // Check if we have space for the title AND the first image block (approx 150mm for first image row)
                        const requiredSpace = titleHeight + 75; // Title + 1/2 page column height estimate
                        if (currentYPos > pageHeight - margin - requiredSpace) { 
                            // If there is not enough space, start a new page for the title
                            doc.addPage();
                            currentYPos = margin;
                            
                            // Print title at the start of the new page
                            doc.setFontSize(16);
                            doc.setTextColor(0); // Reset color to black for text
                            doc.text("Reference Images", margin, currentYPos);
                            currentYPos += titleHeight; // Advance past the title
                            
                            // Footer added immediately after new page 
                            addFooter(doc, margin, pageHeight); 
                        } else {
                            // Print title on the current page if there is space
                            doc.setFontSize(16);
                            doc.setTextColor(0); // Reset color to black for text
                            doc.text("Reference Images", margin, currentYPos);
                            currentYPos += titleHeight; // Advance past the title
                        }
                        // --- End Reference Title Logic ---
                        const imagePadding = 5; // Space between images
                        // Set image width to 45% of the page width (allowing two columns)
                        const singleImgWidth = (pageWidth - margin * 2 - imagePadding) / 2;
                        let rowMaxHeight = 0;
                        
                        for (let i = 0; i < selectedFiles.length; i++) {
                            const file = selectedFiles[i];
                            const reader = new FileReader();
                            reader.readAsDataURL(file);
                            await new Promise(resolve => reader.onloadend = resolve);
                            
                            const imgDataUrl = reader.result;
                            const img = new Image();
                            img.src = imgDataUrl;
                            await new Promise(resolve => img.onload = resolve);
                            
                            const imgRatio = img.width / img.height;
                            const imgPdfHeight = singleImgWidth / imgRatio;
                            // Check if we are starting a new row (i is even)
                            if (i % 2 === 0) {
                                // Advance Y position based on the height of the *previous* completed row
                                currentYPos += rowMaxHeight + (i > 0 ? imagePadding : 0);
                                rowMaxHeight = 0; // Reset max height for the new row
                                // Page break check for the new row start (allowing room for image + footer)
                                if (currentYPos + imgPdfHeight > pageHeight - margin - 10) { // -10 to leave room for footer
                                    doc.addPage();
                                    currentYPos = margin;
                                    
                                    // Print continuation title if needed
                                    doc.setFontSize(16);
                                    doc.text("Reference Images (Cont.)", margin, currentYPos);
                                    currentYPos += titleHeight; // Advance past the title
                                    // Footer added immediately after new page 
                                    addFooter(doc, margin, pageHeight); 
                                }
                            }
                            // Determine image placement coordinates
                            const currentXPos = (i % 2 === 0) ? margin : margin + singleImgWidth + imagePadding;
                            const imageYPos = currentYPos; // Y position is set when the row starts
                            // Track the maximum height in the current row for correct spacing of the next row
                            rowMaxHeight = Math.max(rowMaxHeight, imgPdfHeight);
                            
                            // Add image
                            doc.addImage(imgDataUrl, 'JPEG', currentXPos, imageYPos, singleImgWidth, imgPdfHeight);
                        }
                    }
                    
                    // 3. Add Valuation Methodology and Sources Page (Page 3 or later)
                    const methodologyTitle = "Valuation Methodology and Sources";
                    const methodologyText = `
The final retail valuation is determined using a two-step process:
1. Wholesale/Purchase Offer: The 'Dealer Purchase Offer' is the raw Wholesale/Dealer Acquisition Price provided by the Large Language Model (LLM). The LLM uses real-time Google Search grounding to find the lowest fair market trade-in value for a rifle matching the condition observed in the photos. The confidence level reflects the model's certainty in this acquired data.
2. Projected Retail Value: This value is calculated by applying a standard industry markup to the Purchase Offer (Wholesale Price / 0.65). The resulting figure is then rounded up to the nearest $5.00 to reflect typical retail pricing practices.
The following online sources were referenced by the LLM in real-time to generate the identification details and the estimated wholesale price:
`;
                    let sourceList = reportData.sources || [];
                    
                    // If no specific sources are returned by the LLM, add a generic entry.
                    if (sourceList.length === 0) {
                        sourceList.push({
                            title: "General Market Data (Aggregated by LLM)",
                            uri: "Valuation synthesized from publicly available auction, retail, and wholesale pricing data found via Google Search."
                        });
                    }
                    // Always add a new page for the Sources/Methodology
                    doc.addPage();
                    currentYPos = margin;
                    
                    // Print Title
                    doc.setFontSize(16);
                    doc.setTextColor(0);
                    doc.text(methodologyTitle, margin, currentYPos);
                    currentYPos += 10;
                    // Print Methodology Text (Using splitTextToSize for auto-wrapping)
                    doc.setFontSize(10);
                    doc.setTextColor(50);
                    doc.setFont("helvetica", "normal");
                    const reportPdfWidthMethodology = pageWidth - margin * 2;
                    let textLines = doc.splitTextToSize(methodologyText, reportPdfWidthMethodology);
                    doc.text(textLines, margin, currentYPos);
                    currentYPos += textLines.length * 4.5; // Adjusted line height (was 5) for better spacing
                    // Print Sources
                    doc.setFontSize(10);
                    doc.setTextColor(50);
                    doc.setFont("helvetica", "bold");
                    doc.text("Referenced Sources:", margin, currentYPos);
                    currentYPos += 5;
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(9);
                    sourceList.forEach((source, index) => {
                        const sourceText = `${index + 1}. ${source.title} (${source.uri})`;
                        // Split long lines/URLs to fit within the width
                        let sourceLines = doc.splitTextToSize(sourceText, reportPdfWidthMethodology);
                        // Check for page overflow
                        if (currentYPos + sourceLines.length * 4.5 > pageHeight - margin - 10) {
                            doc.addPage();
                            currentYPos = margin;
                            
                            // Print continuation title if needed
                            doc.setFontSize(10);
                            doc.text("Sources (Cont.):", margin, currentYPos);
                            currentYPos += 5;
                            // Footer added immediately after new page 
                            addFooter(doc, margin, pageHeight); 
                        }
                        doc.text(sourceLines, margin, currentYPos);
                        currentYPos += sourceLines.length * 4.5; // Advance Y position (approx 4.5mm per line)
                    });
                    
                    // Footer added after methodology and source listing 
                    addFooter(doc, margin, pageHeight);
                    doc.save(sanitizedFilename);
                    showMessage("PDF download started!", 'info');
                } catch (error) {
                    console.error("PDF generation failed:", error);
                    showMessage("Failed to generate PDF. Please try again.", 'error');
                } finally {
                    downloadButton.disabled = false;
                }
            });
        }); // End DOMContentLoaded
    </script>
</body>
</html>
