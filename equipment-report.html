<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equipment Report Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .container { max-width: 800px; }
        #report-header {
            display: flex; flex-direction: column; align-items: center;
            padding-bottom: 1rem; border-bottom: 2px solid #e5e7eb; margin-bottom: 1rem;
        }
        .no-break { white-space: nowrap; }
    </style>
</head>

<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center">
<div class="container bg-white rounded-3xl shadow-xl p-8 space-y-8">
    <header class="text-center">
        <img
            src="./bona-fide-iron-logo.jpg"
            alt="Bona Fide Iron"
            class="mx-auto h-16 mb-4"
            onerror="this.style.display='none'; document.getElementById('logo-fallback').style.display='block';"
        >
        <div id="logo-fallback" class="hidden mx-auto mb-4 p-3 rounded-xl bg-yellow-50 text-yellow-800 text-sm" style="display:none;">
            Logo not found. Make sure the file exists in the SAME folder as this HTML and is named exactly:
            <span class="font-semibold">bona-fide-iron-logo.jpg</span>
        </div>

        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">Equipment Report Generator</h1>
        <p class="text-gray-500">Upload up to 20 photos to identify construction equipment and generate a professional report.</p>
        <p class="text-sm text-gray-400 mt-2">PDF includes all images (smaller + compressed).</p>
        <p id="user-id" class="text-xs text-gray-400 mt-2"></p>
    </header>

    <div id="drop-zone" class="w-full rounded-2xl border-4 border-dashed border-gray-300 p-8 text-center transition-colors hover:border-gray-400">
        <input type="file" id="file-input" class="hidden" accept="image/*" multiple>
        <div class="text-lg font-medium text-gray-700">Drag & drop, paste (Ctrl+V), or click to upload images</div>
        <p class="text-sm text-gray-400 mt-2">Maximum of 20 images, up to 4MB each.</p>
        <button id="upload-button" class="mt-6 px-6 py-3 bg-gray-900 text-white font-semibold rounded-xl hover:bg-gray-700 transition-colors">
            Choose Images
        </button>
    </div>

    <div class="w-full">
        <div class="flex flex-col gap-3">
            <label for="url-input" class="text-sm font-medium text-gray-700">
                To add images from the internet, right-click an image → "Copy Image Address" → paste URL below.
            </label>
            <div class="flex items-center gap-3">
                <input type="text" id="url-input" placeholder="Paste image URL here..." class="flex-grow rounded-xl p-3 border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <button id="url-button" class="px-6 py-3 bg-gray-900 text-white font-semibold rounded-xl hover:bg-gray-700 transition-colors">
                    Add from URL
                </button>
            </div>
        </div>
    </div>

    <div class="w-full">
        <div class="flex flex-col gap-3">
            <label for="notes-input" class="text-sm font-medium text-gray-700">
                Optional notes (serial #, hours, attachments, known issues, location, auction notes):
            </label>
            <textarea id="notes-input" rows="3" class="rounded-xl p-3 border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
        </div>
    </div>

    <div id="image-previews" class="flex flex-wrap gap-3 justify-center items-center p-4 rounded-xl bg-gray-50 shadow-inner" style="display:none;"></div>

    <div class="flex flex-col items-center justify-center space-y-4">
        <button id="generate-button" class="w-full px-8 py-4 bg-indigo-600 text-white font-bold text-lg rounded-2xl shadow-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
            Generate Report
        </button>

        <button id="download-button" class="w-full px-8 py-4 bg-gray-500 text-white font-bold text-lg rounded-2xl shadow-lg hover:bg-gray-600 transition-colors hidden">
            Download Report
        </button>

        <div id="status-message" class="text-sm text-center text-gray-600"></div>
    </div>

    <div id="report-container" class="w-full bg-white rounded-2xl shadow-lg p-6 space-y-6" style="display:none;">
        <div id="report-header">
            <img
                src="./bona-fide-iron-logo.jpg"
                alt="Bona Fide Iron"
                class="h-10 mb-2"
                onerror="this.style.display='none';"
            >
            <h2 class="text-2xl font-bold text-gray-900">Equipment Identification Report</h2>
        </div>
        <div id="report-content" class="space-y-4"></div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    // ***************************************************************
    // CRITICAL SECURITY: The API key is set to an empty string.
    // This line MUST be replaced by the build script (render_build.sh).
    const API_KEY = "";
    // ***************************************************************

    // Keep the same “offer is slightly under market” idea
    const PRICE_ADJUSTMENT_PERCENTAGE = 0.05;

    let reportData = null;
    let selectedFiles = [];
    let originalFiles = [];

    let app, db = null, auth, userId;
    let isAuthReady = false;

    async function initFirebase() {
        try {
            if (Object.keys(firebaseConfig).length === 0) {
                isAuthReady = true;
                userId = crypto.randomUUID();
                document.getElementById('user-id').textContent = `User ID: (Local) ${userId.substring(0, 8)}...`;
                return;
            }

            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
            else await signInAnonymously(auth);

            userId = auth.currentUser.uid;
            document.getElementById('user-id').textContent = `User ID: ${userId}`;
            isAuthReady = true;
        } catch (error) {
            console.error("Firebase init error:", error);
            db = null;
            document.getElementById('status-message').textContent =
                "Failed to connect to the database. Some features may not work.";
        }
    }
    initFirebase();

    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const uploadButton = document.getElementById('upload-button');
    const urlInput = document.getElementById('url-input');
    const urlButton = document.getElementById('url-button');
    const notesInput = document.getElementById('notes-input');
    const generateButton = document.getElementById('generate-button');
    const downloadButton = document.getElementById('download-button');
    const imagePreviewsContainer = document.getElementById('image-previews');
    const statusMessage = document.getElementById('status-message');
    const reportContainer = document.getElementById('report-container');
    const reportContent = document.getElementById('report-content');

    const MAX_FILES = 20;
    const MAX_FILE_SIZE_MB = 4;
    const MAX_IMAGE_SIDE_PX = 650;
    const UNSUPPORTED_MIME_TYPES = ['image/avif', 'image/svg+xml'];

    // PDF output sizing you requested
    const PDF_IMAGE_WIDTH_MM = 76; // ~3"
    const PDF_IMAGE_MAX_PX = 900;
    const PDF_JPEG_QUALITY = 0.70;

    function showMessage(message, type = 'info') {
        statusMessage.className = `text-sm text-center mt-4 ${type === 'error' ? 'text-red-600' : 'text-gray-600'}`;
        statusMessage.textContent = message;
    }

    function toggleGenerateButton() {
        generateButton.disabled = selectedFiles.length === 0;
        if (selectedFiles.length === 0 && !reportData) downloadButton.classList.add('hidden');
    }

    function showPreviews() {
        imagePreviewsContainer.innerHTML = '';
        if (selectedFiles.length > 0) {
            imagePreviewsContainer.style.display = 'flex';
            selectedFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imgWrapper = document.createElement('div');
                    imgWrapper.className = 'relative group w-24 h-24 rounded-lg overflow-hidden shadow-md';
                    imgWrapper.innerHTML = `
                        <img src="${e.target.result}" alt="Preview ${index + 1}" class="w-full h-full object-cover">
                        <button class="absolute top-1 right-1 bg-black/50 text-white rounded-full p-1 leading-none text-sm opacity-0 group-hover:opacity-100 transition-opacity" data-index="${index}">
                            &times;
                        </button>
                    `;
                    imagePreviewsContainer.appendChild(imgWrapper);
                };
                reader.readAsDataURL(file);
            });
        } else {
            imagePreviewsContainer.style.display = 'none';
        }
    }

    function processFiles(files) {
        let newFiles = Array.from(files).filter(file => {
            const mimeType = file.type.toLowerCase();
            if (!mimeType.startsWith('image/')) { showMessage(`"${file.name}" is not an image.`, 'error'); return false; }
            if (UNSUPPORTED_MIME_TYPES.includes(mimeType)) { showMessage(`"${file.name}" unsupported format. Use JPG/PNG.`, 'error'); return false; }
            if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { showMessage(`"${file.name}" exceeds ${MAX_FILE_SIZE_MB}MB.`, 'error'); return false; }
            return true;
        });

        if (selectedFiles.length + newFiles.length > MAX_FILES) {
            const limit = MAX_FILES - selectedFiles.length;
            newFiles = newFiles.slice(0, limit);
            showMessage(`Max reached. Added ${limit}. Total: ${MAX_FILES}/${MAX_FILES}`, 'error');
        }

        selectedFiles = [...selectedFiles, ...newFiles].slice(0, MAX_FILES);
        showPreviews();
        toggleGenerateButton();

        if (newFiles.length > 0) showMessage(`Added ${newFiles.length}. Total: ${selectedFiles.length}/${MAX_FILES}`);
    }

    function resizeImage(file) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width, height = img.height;

                if (width > MAX_IMAGE_SIDE_PX || height > MAX_IMAGE_SIDE_PX) {
                    const ratio = Math.max(width / MAX_IMAGE_SIDE_PX, height / MAX_IMAGE_SIDE_PX);
                    width /= ratio; height /= ratio;
                }

                canvas.width = width; canvas.height = height;
                canvas.getContext('2d').drawImage(img, 0, 0, width, height);

                canvas.toBlob(blob => {
                    const resizedFile = new File([blob], file.name, { type: 'image/png' });
                    resolve(resizedFile);
                }, 'image/png');
            };
            img.src = URL.createObjectURL(file);
        });
    }

    async function fileToCompressedJpegDataUrl(file) {
        const dataUrl = await new Promise((resolve, reject) => {
            const r = new FileReader();
            r.onloadend = () => resolve(r.result);
            r.onerror = reject;
            r.readAsDataURL(file);
        });

        const img = new Image();
        img.src = dataUrl;
        await new Promise(resolve => img.onload = resolve);

        let w = img.width, h = img.height;
        if (w > PDF_IMAGE_MAX_PX || h > PDF_IMAGE_MAX_PX) {
            const ratio = Math.max(w / PDF_IMAGE_MAX_PX, h / PDF_IMAGE_MAX_PX);
            w /= ratio; h /= ratio;
        }

        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        canvas.getContext('2d').drawImage(img, 0, 0, w, h);

        return { dataUrl: canvas.toDataURL('image/jpeg', PDF_JPEG_QUALITY), width: w, height: h };
    }

    uploadButton.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => { processFiles(e.target.files); e.target.value = ''; });

    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-gray-500','bg-gray-50'); });
    dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-gray-500','bg-gray-50'); });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('border-gray-500','bg-gray-50'); processFiles(e.dataTransfer.files); });

    window.addEventListener('paste', (e) => {
        const items = e.clipboardData.items;
        const files = [];
        for (let i=0;i<items.length;i++) if (items[i].kind==='file' && items[i].type.startsWith('image/')) files.push(items[i].getAsFile());
        if (files.length>0) processFiles(files);
    });

    urlButton.addEventListener('click', async () => {
        const url = urlInput.value.trim();
        if (!url) return showMessage('Enter a valid image URL.', 'error');
        if (selectedFiles.length >= MAX_FILES) return showMessage(`Max ${MAX_FILES} images.`, 'error');
        if (!url.match(/\.(jpeg|jpg|gif|png|webp|svg|avif)$/i)) return showMessage('URL must end in .jpg/.png/etc', 'error');

        showMessage('Fetching image from URL (may fail due to CORS)...', 'info');
        urlButton.disabled = true;

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const contentType = response.headers.get('Content-Type')?.toLowerCase();
            if (!contentType || !contentType.startsWith('image/')) throw new Error(`Not an image. Content-Type: ${contentType}`);
            if (UNSUPPORTED_MIME_TYPES.includes(contentType)) return showMessage(`Unsupported format: ${contentType}`, 'error');

            const blob = await response.blob();
            const filename = url.substring(url.lastIndexOf('/') + 1) || 'image';
            const file = new File([blob], filename, { type: blob.type });

            if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) showMessage(`Image exceeds ${MAX_FILE_SIZE_MB}MB.`, 'error');
            else { processFiles([file]); urlInput.value=''; showMessage('Image added successfully.'); }
        } catch (err) {
            console.error(err);
            showMessage(`Failed to load URL image: ${err.message} (likely CORS)`, 'error');
        } finally {
            urlButton.disabled = false;
        }
    });

    imagePreviewsContainer.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const index = e.target.getAttribute('data-index');
            selectedFiles.splice(index, 1);
            showPreviews();
            toggleGenerateButton();
            showMessage(`Removed image ${parseInt(index)+1}.`);
        }
    });

    generateButton.addEventListener('click', async () => {
        if (!API_KEY) return showMessage("API Key is missing. (Build script didn't inject it)", 'error');
        if (!isAuthReady) return showMessage("Database status unknown. Please wait a moment.", 'error');

        showMessage("Generating report... Analyzing images and searching.", 'info');
        generateButton.disabled = true;
        downloadButton.classList.add('hidden');
        reportContainer.style.display = 'none';

        let retries = 0;
        const MAX_RETRIES = 3;

        originalFiles = [...selectedFiles];

        const resetUIAndResources = async () => {
            selectedFiles = [];
            fileInput.value = '';
            showPreviews();
            await new Promise(res => setTimeout(res, 500));
        };

        async function callApiWithRetry() {
            try {
                showMessage("Step 1/3: Resizing and preparing images...", 'info');
                const resizedFiles = await Promise.all(originalFiles.map(file => resizeImage(file)));

                const base64Images = await Promise.all(
                    resizedFiles.map(file => new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const dataUrl = reader.result;
                            resolve({
                                data: dataUrl.split(',')[1],
                                mimeType: dataUrl.split(',')[0].split(':')[1].split(';')[0],
                            });
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    }))
                );

                showMessage("Step 2/3: Sending request to model...", 'info');
                const userNotes = notesInput.value.trim();

                const reportPrompt = `
You are a construction equipment inspector and appraiser specializing in dealer purchase offers and resale pricing.

Identify the equipment from photos:
- Type, make, model, and any visible serial/VIN and hour meter.
- Note attachments (bucket, thumb, coupler, etc.) and options.
- Summarize visible condition conservatively (photos only).
- Use Google Search grounding to estimate a realistic retail/asking price for comparable units (same model/era/condition).

Return ONLY valid JSON with this exact structure (no markdown, no extra keys, no citations like [1]):
{
  "modelGuess": "string",
  "equipmentType": "string",
  "identification": "string",
  "productionEra": "string",
  "features": "string",
  "conditionNotes": "string",
  "keySystems": {
    "undercarriageOrTires": "string",
    "hydraulicsAndLeaks": "string",
    "engineCoolingElectrical": "string",
    "cabControlsDisplays": "string",
    "structureBoomBucketPins": "string"
  },
  "recommendations": "string",
  "disclaimer": "string",
  "valuation": {
    "estimatedRetailValueUSD": "string",
    "valuationConfidence": "string"
  }
}

CRITICAL:
- estimatedRetailValueUSD must be a SINGLE number like "107000" with no $ and no commas and no ranges.
- If you truly cannot estimate, use "Unknown".
`;

                const payload = {
                    contents: [{
                        parts: [
                            { text: reportPrompt },
                            { text: `User Notes: ${userNotes}` },
                            ...base64Images.map(img => ({ inlineData: { mimeType: img.mimeType, data: img.data } }))
                        ]
                    }],
                    tools: [{ "google_search": {} }],
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    if (response.status === 503 && retries < MAX_RETRIES) {
                        retries++;
                        showMessage(`Model overloaded. Retrying... (${retries}/${MAX_RETRIES})`, 'info');
                        await new Promise(res => setTimeout(res, 2000 * retries));
                        return callApiWithRetry();
                    }
                    throw new Error(`API Error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                let jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!jsonText) {
                    console.error("Empty model response:", result);
                    throw new Error("Model returned empty response (often request size or image processing).");
                }

                let sources = [];
                const groundingMetadata = result.candidates?.[0]?.groundingMetadata;
                if (groundingMetadata?.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(a => ({ uri: a.web?.uri, title: a.web?.title }))
                        .filter(s => s.uri && s.title);
                }

                const jsonMatch = jsonText.match(/```json\n([\s\S]*?)\n```/);
                if (jsonMatch) jsonText = jsonMatch[1].trim();
                else {
                    jsonText = jsonText.trim();
                    const first = jsonText.indexOf('{');
                    const last = jsonText.lastIndexOf('}');
                    if (first !== -1 && last !== -1 && last > first) jsonText = jsonText.substring(first, last + 1);
                }

                let report;
                try { report = JSON.parse(jsonText); }
                catch (e) { console.error("Bad JSON:", jsonText); throw new Error("JSON parsing failed."); }

                reportData = report;
                reportData.sources = sources;

                const retailStr = (report.valuation?.estimatedRetailValueUSD || "0").replace(/[$,]/g, '').trim();
                const retailValue = parseFloat(retailStr);

                let dealerOffer = 'N/A';
                let projectedRetail = 'N/A';

                if (!isNaN(retailValue) && retailValue > 0) {
                    projectedRetail = retailValue.toFixed(2);
                    const adjusted = retailValue * (1 - PRICE_ADJUSTMENT_PERCENTAGE);
                    dealerOffer = adjusted.toFixed(2);
                }

                const ks = report.keySystems || {};

                reportContent.innerHTML = `
                    <div class="p-4 bg-gray-50 rounded-lg">
                        <p class="font-bold">Model Guess:</p>
                        <p>${report.modelGuess || "Unknown"}</p>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Equipment Type</h3>
                        <p class="text-gray-700">${report.equipmentType || "Unknown"}</p>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Identification</h3>
                        <p class="text-gray-700">${report.identification || "Unknown"}</p>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Production Era</h3>
                        <p class="text-gray-700">${report.productionEra || "Unknown"}</p>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Features</h3>
                        <p class="text-gray-700">${report.features || "Unknown"}</p>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Valuation</h3>
                        <div class="mt-2 space-y-3 p-4 border rounded-xl bg-green-50">
                            <div class="flex justify-between font-medium text-gray-700">
                                <span class="text-blue-700">Dealer Purchase Offer:</span>
                                <span class="text-blue-700 font-bold no-break">$${dealerOffer}</span>
                            </div>
                            <div class="flex justify-between font-medium text-gray-700 border-t pt-3 mt-3">
                                <span>Estimated Retail / Asking:</span>
                                <span class="text-green-700 font-bold no-break">$${projectedRetail}</span>
                            </div>
                        </div>
                        <div class="mt-4 text-sm text-gray-600">
                            <strong>Confidence Level:</strong>
                            <span class="font-semibold text-gray-800">${report.valuation?.valuationConfidence || "Unknown"}</span>
                        </div>
                        <p class="mt-2 text-xs text-gray-500">
                            *Sources (if any) are included on the final PDF page.
                        </p>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Condition Notes</h3>
                        <p class="text-gray-700">${report.conditionNotes || "Unknown"}</p>
                    </div>

                    <div class="p-4 bg-gray-50 rounded-lg space-y-2">
                        <div><span class="font-semibold">Undercarriage/Tires:</span> ${ks.undercarriageOrTires || "Unknown"}</div>
                        <div><span class="font-semibold">Hydraulics/Leaks:</span> ${ks.hydraulicsAndLeaks || "Unknown"}</div>
                        <div><span class="font-semibold">Engine/Cooling/Electrical:</span> ${ks.engineCoolingElectrical || "Unknown"}</div>
                        <div><span class="font-semibold">Cab/Controls/Displays:</span> ${ks.cabControlsDisplays || "Unknown"}</div>
                        <div><span class="font-semibold">Structure/Boom/Bucket/Pins:</span> ${ks.structureBoomBucketPins || "Unknown"}</div>
                    </div>

                    <div>
                        <h3 class="font-semibold text-lg text-gray-800">Recommendations</h3>
                        <p class="text-gray-700">${report.recommendations || "Unknown"}</p>
                    </div>

                    <div class="p-4 mt-4 bg-yellow-50 text-sm text-yellow-800 rounded-lg">
                        <p><strong>Disclaimer:</strong> ${report.disclaimer || "This report is based on photos only and is not a substitute for an in-person inspection."}</p>
                    </div>
                `;

                reportContainer.style.display = 'block';
                downloadButton.classList.remove('hidden');
                showMessage("Report generated successfully! (Step 3/3 complete)", 'info');

                if (isAuthReady && db) {
                    try {
                        const reportRef = doc(db, `artifacts/${appId}/users/${userId}/reports/${Date.now()}`);
                        await setDoc(reportRef, report);
                    } catch (dbError) {
                        console.error("Firestore save failed:", dbError);
                        showMessage("Report generated, but failed to save to database.", 'warning');
                    }
                }

            } catch (error) {
                console.error("Report generation error:", error);
                showMessage(`Failed to generate report: ${error.message}`, 'error');
                reportData = null;
                await resetUIAndResources();
            } finally {
                generateButton.disabled = false;
            }
        }

        callApiWithRetry();
    });

    downloadButton.addEventListener('click', async () => {
        const { jsPDF } = window.jspdf;
        const reportElement = document.getElementById('report-container');

        showMessage("Preparing PDF for download...", 'info');
        downloadButton.disabled = true;

        const addFooter = (doc, margin, pageHeight) => {
            doc.setFontSize(8);
            doc.setTextColor(150);
            doc.setFont("helvetica", "normal");
            const footerText = "Bona Fide Iron | WWW.Ludditelearning.com";
            doc.text(footerText, margin, pageHeight - 5);
        };

        try {
            const modelGuess = reportData?.modelGuess || 'Unknown_Equipment';
            const dateString = new Date().toISOString().split('T')[0];
            const sanitizedFilename = modelGuess.replace(/[/\s]+/g, '_') + '_' + dateString + '_Equipment_Report.pdf';

            const doc = new jsPDF('p', 'mm', 'a4');
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 10;

            const reportCanvas = await html2canvas(reportElement, { scale: 3, width: reportElement.offsetWidth });
            const reportImgData = reportCanvas.toDataURL('image/jpeg', 0.95);

            const reportRatio = reportCanvas.width / reportCanvas.height;
            const reportPdfWidth = pageWidth - margin * 2;
            const reportPdfHeight = reportPdfWidth / reportRatio;

            doc.addImage(reportImgData, 'JPEG', margin, margin, reportPdfWidth, reportPdfHeight);
            addFooter(doc, margin, pageHeight);

            if (originalFiles.length > 0) {
                doc.addPage();
                let y = margin;

                doc.setFontSize(16);
                doc.setTextColor(0);
                doc.text("Reference Images", margin, y);
                y += 8;
                addFooter(doc, margin, pageHeight);

                const imagePadding = 6;
                let rowMaxHeight = 0;

                for (let i = 0; i < originalFiles.length; i++) {
                    const file = originalFiles[i];
                    const { dataUrl, width, height } = await fileToCompressedJpegDataUrl(file);

                    const imgRatio = width / height;
                    const imgPdfHeight = PDF_IMAGE_WIDTH_MM / imgRatio;

                    if (i % 2 === 0) {
                        if (i > 0) y += rowMaxHeight + imagePadding;
                        rowMaxHeight = 0;

                        if (y + imgPdfHeight > pageHeight - margin - 10) {
                            doc.addPage();
                            y = margin;

                            doc.setFontSize(16);
                            doc.text("Reference Images (Cont.)", margin, y);
                            y += 8;
                            addFooter(doc, margin, pageHeight);
                        }
                    }

                    const x = (i % 2 === 0) ? margin : (margin + PDF_IMAGE_WIDTH_MM + imagePadding);
                    rowMaxHeight = Math.max(rowMaxHeight, imgPdfHeight);

                    doc.addImage(dataUrl, 'JPEG', x, y, PDF_IMAGE_WIDTH_MM, imgPdfHeight);
                }
                addFooter(doc, margin, pageHeight);
            }

            // Sources page
            doc.addPage();
            let y2 = margin;
            doc.setFontSize(16);
            doc.setTextColor(0);
            doc.text("Sources (if available)", margin, y2);
            y2 += 10;

            doc.setFontSize(10);
            doc.setTextColor(50);
            doc.setFont("helvetica", "normal");

            let sources = reportData?.sources || [];
            if (!sources.length) {
                sources = [{ title: "Google Search Grounding", uri: "No specific links returned by the model for this run." }];
            }

            const bodyWidth = pageWidth - margin * 2;
            sources.forEach((s, idx) => {
                const line = `${idx + 1}. ${s.title} (${s.uri})`;
                const lines = doc.splitTextToSize(line, bodyWidth);
                if (y2 + lines.length * 4.5 > pageHeight - margin - 10) {
                    doc.addPage();
                    y2 = margin;
                    addFooter(doc, margin, pageHeight);
                }
                doc.text(lines, margin, y2);
                y2 += lines.length * 4.5;
            });

            addFooter(doc, margin, pageHeight);

            doc.save(sanitizedFilename);
            showMessage("PDF download started!", 'info');
        } catch (error) {
            console.error("PDF generation failed:", error);
            showMessage("Failed to generate PDF. Please try again.", 'error');
        } finally {
            downloadButton.disabled = false;
        }
    });

    toggleGenerateButton();
</script>
</body>
</html>
